<html>
<head>
  <style type="text/css">
    body   { text-align:   justify;
             margin-right: 10%;
             margin-left:  10%; }
    h1     { margin-left:  -9%; }
    h2     { margin-left:  -6%; }
    h3     { margin-left:  -3%; }
    pre    { background: #FFFFCC; padding: 1em; border: none; }
    p.note { background: #CCFFFF; padding: 1em; }
  </style>
</head>
<body>

<!---------------------------------------------------------------------------->

<pre style="font-size:3em; font-weight:bold; padding: 0.25em">
  |||
  O o  Electro
   -
</pre>

<p> Electro is an application development framework designed for use
on cluster-driven tiled displays.  Electro is based upon the MPI
process model and is bound to the Lua programming language.  With
support for 3D graphics, 2D graphics, audio, and input handling,
Electro provides an easy-to-use scripting system for interactive
applications spanning multiple processors and displays. </p>

<h1> This Document </h1>

<p> This document details the functions and data types of the Electro
API.  A knowledge of the Lua Programming Language, version 5.0, is
prerequisite.  Lua documentation and tutorials may be found at <a
href="http://www.lua.org/docs.html"> the official Lua site. </a></p>

<p> This document includes a number of Lua code examples.  These
examples are distinguished from the main text as follows: </p>

<pre>
print("Hello, World!")
</pre>

<p> This document also includes a number of paragraphs giving design
rationale.  These describe some of the trade-offs and design decisions
made during the development of Electro.  They are presented here in
the hope that they will provide the reader with a more thorough
understanding of the details of the implementation.  Rationale
paragraphs are distinguished from the main text as follows: </p>

<p class="note"> Electro adheres to a number of closely-held design
principles.  The primary principles are simplicity, orthogonality, and
efficiency.  Violations of these principles do appear, but not without
serious consideration. </p>

<!---------------------------------------------------------------------------->

<h1> Types </h1>

<h2> Entity </h2>

<h2> Object </h2>

<h2> Sprite </h2>

<h2> Light </h2>

<h2> Pivot </h2>

<!---------------------------------------------------------------------------->

<h1> Functions </h1>

<!---------------------------------------------------------------------------->

<h2> Entity Functions </h2>

<p> The following functions act on entities.  The entity argument of
each function may take any entity value, including object, sprite,
lightsource, and camera. </p>

<h3> Absolute Transformation </h3>
<dl>
<dt><tt> entity_position(entity, x, y, z) </tt>

<dd><p> Specify the position of the entity.  Position is given in the
coordinate system of the entity's parent. </p>

<dt><tt> entity_rotation(entity, x, y, z) </tt>

<dd><p> Specify the rotation of the entity.  The 3 values give the
angles of rotation in degrees about the X, Y, and Z axes.  Rotation is
given in the coordinate system of the entity's parent. </p>

<dt><tt> entity_scale(entity, x, y, z) </tt>

<dd><p> Specify the scale of the entity.  The 3 values give scale
multipliers along the X, Y, and Z axes.  Scale is given in the
coordinate system of the entity's parent. </p>

</dl>

<h3> Relative Transformation </h3>

<p class="note"> Strictly speaking, to provide both absolute and
relative transformation functions is to violate the principle of
orthogonality.  In this case, I just couldn't resist.  Inspiration for
this feature is drawn from Blitz3D, which showed that relative
transform is very beginner-friendly, leading to a very intuitive
turtle-style system of entity control. </p>

<dl>
<dt><tt> entity_move(entity, x, y, z) </tt>

<dd><p> Move the entity relative to its current position.  X is to the
right, Y is up, and Z axis is to the rear, as defined by the entity's
current orientation. </p>

<p class="note"> It might be more clear to the beginner if the Z axis
to pointed forward rather than back.  However, this would be in
conflict with the normal right-handed coordinate system, and would
only lead to inconsistency and confusion for the experienced 3D
user. </p>

<dt><tt> entity_turn(entity, x, y, z) </tt>

<dd><p> Rotate the entity relative to its current orientation.
Rotation about the X, Y, and Z axes corresponds to pitch, yaw, and
roll, respectively. </p>

</dl>

<!---------------------------------------------------------------------------->

<h2> Configuration Functions </h2>

<dl>

<dt><tt> add_tile(local_x, local_y, global_x, global_y, width, height) </tt>

<dd><p> Make a tile. </p>

</dl>

<pre>
w  = 1600
h  = 1200
dx = w + 128
dy = h + 128

global_w  =  dx * 2
global_h  =  dy * 2
global_x  = -global_w / 2
global_y  = -global_h / 2

add_tile("nico1-10",    0, 0, global_x + dx * 2, global_y,          w, h)
add_tile("nico1-10", 1600, 0, global_x + dx * 3, global_y,          w, h)
add_tile("nico2-10",    0, 0, global_x + dx * 2, global_y + dy,     w, h)
add_tile("nico2-10", 1600, 0, global_x + dx * 3, global_y + dy,     w, h)
</pre>

<!---------------------------------------------------------------------------->

<h1> Callbacks </h1>

<p> Callback functions are the mechanism by which Electro Lua
applications respond to user interface events.  An application may
define these functions as needed.  If a function exists then it is
invoked when the corresponding event occurs.  Callback functions
should return a boolean value to indicate whether the event resulted
in a dirty screen.  Returning <tt>true</tt> schedules a screen update
to occur at the next opportunity. </p>

<dl>
<dt><tt> do_start() </tt> <dd><p> This callback is invoked precisely
once at the beginning of a run.  It occurs after all of the scripts
named on the command line have finished executing, but before any
event processing begins.  Applications are free to perform Lua state
initialization upon initial execution, but Electro object
initialization <i>must</i> be performed in the <tt>do_start</tt>
function.</p>

<p class="note"> This callback is a bit of a hack.  It is necessary
because Electro objects cannot be initialized until the OpenGL context
exists.  However, the OpenGL context cannot be created until the
viewport configuration is known.  So, startup must proceed in two
distinct phases, one before context creation, and one after.  The
<tt>do_start</tt> callback is this second phase. </p>

<dt><tt> do_point(dx, dy) </tt> <dd><p> This callback is invoked
whenever the mouse pointer moves within the Electro main window.
Motion is reported relatively, so the pointer may move an unlimited
distance in any direction.  Absolute position is not reported.  If
absolute mouse position is necessary, then it must be tracked
manually, as follows: </p>

<pre>
mouse_x = 0
mouse_y = 0

function do_point(dx, dy)
    mouse_x = mouse_x + dx
    mouse_y = mouse_y + dy
    return true
end
</pre>

<dt><tt> do_click(b, s) </tt><dd><p> This callback is invoked whenever
a mouse button is pressed or released.  The <tt>b</tt> argument gives
the button number, 1, 2, 3, etc.  The <tt>s</tt> argument is a boolean
giving button state.  A value of <tt>true</tt> indicates the button
has been pressed, and <tt>false</tt> indicates it has been released.
Note, on most modern systems mouse wheel up and down are reported as
presses of buttons 4 and 5.  Button press events on wheel buttons do
not have accompanying release events. </p>

<dt><tt> do_timer(t) </tt><dd><p> The <tt>do_timer</tt> callback is
invoked regularly while idling is enabled.  The <tt>t</tt> argument
gives the amount of time, in seconds, that has passed since the last
time the callback was invoked.  The rate of callback is not defined,
though it may be inferred to be "often enough."  In practice it is
usually around 30 times per second, though this will decrease with
graphical complexity.  The <tt>do_timer</tt> function is intended to
be used to update animations and other background processes.
Applications should be sure to return <tt>true</tt> in order to force
an update to the display.</p>

<p class="note"> The update rate of the <tt>do_timer</tt> callback is
deliberately obscured because it is nearly impossible to guarantee.
While it might make sense to allow an application to request a
callback rate, this request can only be precisely filled in a limited
number of cases.  The idle timer does <i>not</i> free-run.
Free-running in Electro is bad because MPI synchronization is
unpredictable and events tend to queue up, leading to sluggish
behavior.  The application developer may count on the fact that
<tt>do_timer</tt> is invoked as often as is possible, such that
performance will not suffer. </p>

<dt><tt> do_keyboard(k, s) </tt><dd><p> This callback is invoked
whenever a key is pressed or released.  The <tt>s</tt> argument is a
boolean giving the key state.  The <tt>k</tt> argument gives a key
identifier.  For most keys, this gives the ASCII value of the
unshifted character.  For non-ASCII keys and modifiers it is a unique
identifier outside of the range of ASCII.  A full listing of keys and
their associated values would be lengthy and uninteresting.  When in
doubt about the value of a key, query it interactively as follows:
</p>

<pre>
function do_keyboard(k, s)
    if s then
        print(k, "down")
    else
        print(k, "up")
    end
    return false
end
</pre>

<dt><tt> do_joystick(n, b, s) </tt><dd><p> This callback is invoked
whenever a joystick button is pressed or released.  The <tt>n</tt>
argument gives the joystick device number.  The <tt>b</tt> argument
gives the button number.  The <tt>s</tt> argument is a boolean giving
button state.  Applications respond to button presses in an
event-driven fashion, but they should read joystick axis input more
continuously.  Usually joystick axes are aquired by calling
<tt>joystick_x(n)</tt> and <tt>joystick_y(n)</tt> in a
<tt>do_timer</tt> callback. </p>

</dl>

<!---------------------------------------------------------------------------->

<p><address> rlk (at) evl.uic.edu </address></p>