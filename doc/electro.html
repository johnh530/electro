<html>
<head>
  <style type="text/css">
    body   { text-align:   justify;
             margin-right: 12%;
             margin-left:  12%; }
    h1     { margin-left: -12%; }
    h2     { margin-left:  -9%; }
    h3     { margin-left:  -6%; }
    h4     { margin-left:  -3%; }
    dt     { background: #EEEEEE; padding: 0.5em; }
    pre    { background: #FFFFCC; padding: 1.0em; }
    p.note { background: #CCFFFF; padding: 1.0em; }
  </style>
</head>
<body>

<!---------------------------------------------------------------------------->

<pre style="font-size:3em; font-weight:bold; padding: 0.25em">
  |||
  O o  Electro
   -
</pre>

<p> Electro is an application development environment designed for use
on cluster-driven tiled displays.  Electro is based upon the MPI
process model and is bound to the Lua programming language.  With
support for 3D graphics, 2D graphics, audio, and input handling,
Electro provides an easy-to-use scripting system for interactive
applications spanning multiple processors and displays. </p>

<h1> This Document </h1>

<p> This document details the functions and data types of the Electro
API.  A knowledge of the Lua Programming Language, version 5.0, is
prerequisite.  Lua documentation and tutorials may be found at <a
href="http://www.lua.org/docs.html"> the official Lua site. </a></p>

<p> Electro API function definitions appear here as follows:

<dl><dt><i>value</i> = <tt>function</tt>(<i>arguments</i>)<dd></p>
Invoke <tt>function</tt> with <i>arguments</i> giving a <i>value</i>.
</p></dl>

<p> This document includes a number of Lua code examples.  These
examples are distinguished from the main text as follows: </p>

<pre>
print("Hello, World!")
</pre>

<p> This document also includes a number of paragraphs giving design
rationale.  These describe some of the trade-offs and design decisions
made during the development of Electro.  They are presented here in
the hope that they will provide the reader with a more thorough
understanding of the details of the implementation.  Rationale
paragraphs are distinguished from the main text as follows: </p>

<p class="note"> The implementation of Electro adheres to a number
of closely-held design principles: simplicity, orthogonality, and
efficiency.</p>

<!---------------------------------------------------------------------------->

<h1> API </h1>

<p> The Electro API is encapsulated in a Lua namespace "<tt>E</tt>".
The namespace specifier is omitted in this documentation, though it is
included in the examples.  Be sure to precede all Lua function and
constant references with the "<tt>E</tt>" namespace specifier, or they
will be reported as undefined.  </p>

<pre>
E.set_background(0.0, 0.5, 1.0)
</pre>

<h2> Entity API </h2>

<p> The core of any Electro application is the scene graph.  The scene
graph is a very common organizing scheme in 3D graphics, and examples
of its use abound.  Other scene graph libraries include

<a href="http://oss.sgi.com/projects/inventor/">Open Inventor</a>,
<a href="http://www.blitzbasic.com/">Blitz3D</a>,
<a href="http://www.openscenegraph.org/">Open Scene Graph</a>,
<a href="http://www.opensg.org/">OpenSG</a>,

and many others.  Users of other scene-graph-based libraries should
find the Electro API unsurprising. </p>

<p> Scene graph functionality is organized into a small class
hierarchy.  The entity base class handles all of the common properties
and behaviours of scene graph elements, most notably 3D
transformation, and the parent-child relationships that hold a scene
hierarchy together.  The subclasses handle the specifics of
controlling the view and lighting, drawing 3D and 2D geometry, etc.
The class hierarchy is as follows: </p>

<ul>
<a href="#entity"> Entity </a>
<ul>
<li><a href="#object"> Object </a>
<li><a href="#sprite"> Sprite </a>
<li> Camera
<li><a href="#light">  Light  </a>
<li><a href="#pivot">  Pivot  </a>
<li><a href="#galaxy"> Galaxy </a>
</ul>
</ul>

<!---------------------------------------------------------------------------->

<h3> Constructors </h3>

<p> Constructor functions instantiate scene graph objects. </p>

<dl>

<dt><i>object</i> = <tt>create_object</tt>(<i>filename</i>)<dd><p>
Load an OBJ format 3D object and return an Electro object entity.
This is the normal means of importing 3D geometry into an Electro
application.  It supports polygonal geometry in OBJ file format,
including material files and texture maps.  The OBJ export capabilities
of Maya, Lightwave, Wings3D, and Milkshape are known to be compatible.
</p>

<p class="note"> The Electro OBJ loader lacks support for freeform
curve specification.  This is actually due to the fact that the
Electro renderer lacks the abality to render freeform curves.  Any
curve specifiers appearing in OBJ files will be silently ignored.
If curves are required, tessalate them using your favorite 3D
modeller. </p>

<p class="note"> The Electro OBJ loader allows one non-standard
extension to the OBJ specification.  An MTL file may include "Ke"
specifiers which behave like "Kd", "Ka", and "Ks" specifiers but
define an emissive material property rather than a diffuse, ambient,
or specular property.  Standard exporters do not produce this tag,
and importers simply ignore it, so it does not get in the way of
normal OBJ file usage.</p>

<dt><i>sprite</i> = <tt>create_sprite</tt>(<i>filename</i>)<dd><p>
Load an image file and create a sprite entity.  A sprite consists of a
single quadrilateral, textured using the given image.  Image files may
be in JPG or PNG format.  The default size of the sprite object is
equal to the size of the source image.  Commonly, sprite objects are
used as billboards in 3D scenes, or are displayed as 2D overlays using
an orthogonal camera.  </p>

<p class="note"> Unextended OpenGL requires that the width and height
of all texture map images be a power of two.  It can be inconvenient
to satisfy this requirement, so Electro automatically rescales
non-power-of-two textures up to the nearest power-of-two size.  This
is only done internally, so a sprite's size and aspect ratio will
reflect the <i>original</i> image attributes.  The scaling is done
using the standard OpenGL utility method, but it can still result in
image quality degradation.  If you are picky about image quality, or
you desire pixel-for-pixel correctness, be sure to use only
power-of-two source images.  The same applies to texture images loaded
by <tt>create_object</tt>.</p>

<dt><i>camera</i> = <tt>create_camera</tt>(<i>type</i>)<dd><p> Create
a camera of the given type.  To be visible in a scene, all entities
must be descendants of a camera entity.  Because of this, cameras are
commonly left unparented and allowed to remain at the root.  Here are
the defined camera types:</p>

<ul>

<li><tt>camera_type_orthogonal</tt><p> An orthogonal camera uses an
orthogonal projection.  By default, the aperture of an orthogonal
camera matches the total size of the current display, which is
appropriate for pixel-correct 2D overlays.</p>

<li><tt>camera_type_perspective</tt><p>A perspective camera uses a
perspective projection.  By default the aperture of a perspective
camera is one unit high, with width determined by the aspect ratio of
the total display. </p>

</ul>

<p>A scene is allowed to include any number of cameras.  One
reasonable configuration is to include one perspective camera for the
display of 3D objects, and one orthogonal camera for the display of 2D
overlays.  </p>

<dt><i>light</i> = <tt>create_light</tt>(<i>type</i>)<dd><p> Create a
light source of the given type.  To be illuminated, all entities must
be descendants of a light entity.  Conversely, entities which should
appear unshaded and fully-bright should not descend from a light
entity.  Here are the defined light types: </p>

<ul>

<li><tt>light_type_positional</tt><p> A positional light provides a
localized light from within the scene.</p>

<li><tt>light_type_directional</tt><p> A directional light source
provides a parallel light from infinitely far away.  Light is directed
along the vector from the position of a directional light source to
the origin of the light's coordinate system (determined by any
transformations defined by parent entities).</p>

</ul>

<p class="note"> In the implementation, the only difference between
positional and directional light sources is the value of the <i>w</i>
component of the homogeneous position of the light.  A positional
light has <i>w=1</i> and a directional light has <i>w=0</i>, thus the
homogeneous position vector is finite or infinite in length,
respectively. </p>

<dt><i>pivot</i> = <tt>create_pivot</tt>()<dd><p> Create a pivot
entity.  A pivot does nothing, but is useful as a grouping entity.  As
it has all the properties of an entity, including transformation and
render flags, It provides a mechanism by which the transform hierarchy
may be extended and controlled.  </p>

<dt><i>galaxy</i> = <tt>create_galaxy</tt>(<i>filename</i>)<dd><p>
Load a galaxy definition from the named file and return a galaxy
entity.  A galaxy entity is a static 3D collection of particles,
organized into a BSP structure for efficient rendering.</p>

<p class="note"> A galaxy object must have the
<tt>examples/star.fp</tt> and <tt>examples/star.vp</tt> fragment and
vertex programs applied to it before it will render correctly.  See
<tt>set_entity_frag_prog</tt> and <tt>set_entity_vert_prog</tt>.</p>

<p class="note"> The galaxy object should be considered a hack.  It
has only a very specific use.  It will probably be removed in a future
revision of the Electro API, or possibly abstracted into a general
particle system.  </p>

<dt><i>entity</i> = <tt>create_clone</tt>(<i>entity</i>)<dd><p>
Duplicate the given entity.  Cloning allows entities to be instanced
within a scene graph.  Cloning an object is more efficient than
recreating an object from scrach, so cloning is often useful in
circumstances where large numbers of similar objects are frequently
created and destroyed.</p>

<p> Note, however, that a clone is a <i>shallow</i> copy of the
original.  A clone has all of the attributes of a distinct entity, but
it shares the attributes specific to its derived type.  For example,
if a scaling operation is applied to a cloned entity, only that entity
will be scaled.  However if the color of a cloned light source is
changed, all instances of the original light source will change.

</dl>

<!---------------------------------------------------------------------------->

<a name="entity"><h3> Entity </h3>

<p> The following functions act on entities.  The entity argument of
each function may take any entity value, including object, sprite,
camera, light, and pivot. </p>

<h4> Hierarchy Management </h4>
<dl>

<dt><tt>parent_entity</tt>(<i>entity, parent</i>)<dd><p> Include
<i>entity</i> as a child of <i>parent</i>.  This will cause
<i>entity</i> to be drawn in the coordinate system of <i>parent</i>,
using its graphics state.  If <i>entity</i> is already the child of
some parent entity prior to the call, it is cleanly removed from that
parent's child list.  An entity may be unparented by specifying a
<i>parent</i> entity of <tt>nil</tt>.

<dt><tt>delete_entity</tt>(<i>entity</i>)<dd><p> Remove <i>entity</i>
from the scene hierarchy and release all resources associated with it.
Any children of <i>entity</i> will be recursively deleted as well.  If
<i>entity</i> is a clone, then the entity itself will be removed, but
any resources shared by other instances of the same entity will
remain.

<dt><i>parent</i> = <tt>get_entity_parent</tt>(<i>entity</i>)<dd><p>
Return the parent of <i>entity</i>, or <tt>nil</tt> if it is
unparented.</p>

<dt><i>child</i> = <tt>get_entity_child</tt>(<i>entity</i>,
<i>n</i>)<dd><p> Return the <tt>n</tt>th child of <i>entity</i>, or
<tt>nil</tt> if it has no such child.  Unparented entities may be
referenced as children of <tt>nil</tt>.  The first child is at index
<i>0</i>.</p>

</dl>

<!---------------------------------------------------------------------------->

<h4> Absolute Transformation </h4>
<dl>

<dt><tt>set_entity_position</tt>(<i>entity, x, y, z</i>)<dd><p>
Specify the position of the entity.  Position is given in the
coordinate system of the entity's parent. </p>

<dt><tt>set_entity_rotation</tt>(<i>entity, x, y, z</i>)<dd><p>
Specify the rotation of the entity.  The 3 values give the angles of
rotation in degrees about the X, Y, and Z axes.  Rotation is given in
the coordinate system of the entity's parent. </p>

<dt><tt>set_entity_scale</tt>(<i>entity, x, y, z</i>)<dd><p> Specify
the scale of the entity.  The 3 values give scale multipliers along
the X, Y, and Z axes.  Scale is given in the coordinate system of the
entity's parent. </p>

</dl>

<!---------------------------------------------------------------------------->

<h4> Relative Transformation </h4>

<p class="note"> Strictly speaking, to provide both absolute and
relative transformation functions is to violate the principle of
orthogonality.  In this case, I just couldn't resist.  Inspiration for
this feature is drawn from Blitz3D, which showed that relative
transform is very beginner-friendly, leading to a very intuitive
turtle-style system of entity control. </p>

<dl>

<dt><tt>move_entity</tt>(<i>entity, x, y, z</i>)<dd><p> Move the
entity relative to its current position.  X is to the right, Y is up,
and Z axis is to the rear, as defined by the entity's current
orientation. </p>

<p class="note"> It might be more clear to the beginner if the Z axis
to pointed forward rather than back.  However, this would be in
conflict with the normal right-handed coordinate system, and would
only lead to inconsistency and confusion for the experienced 3D
user. </p>

<dt><tt>turn_entity</tt>(<i>entity, x, y, z</i>)<dd><p> Rotate the
entity relative to its current orientation.  Rotation about the X, Y,
and Z axes corresponds to pitch, yaw, and roll, respectively.</p>

</dl>

<!---------------------------------------------------------------------------->

<h4> Rendering properties </h4>
<dl>

<dt><tt>set_entity_alpha</tt>(<i>entity, alpha</i>)<dd><p> Specify the
transparency of the entity.  A value of 1.0 is fully opaque and 0.0 is
fully invisible.  This transparency value propagates down the
hierarchy.  Transparency values specified by child nodes will
accumulate.  That is, if a parent and a child both specify
<i>alpha</i>=0.5 then the child will appear with a transparency of
0.25.</p>

<dt><tt>set_entity_frag_prog</tt>(<i>entity, file</i>)<dd><p> Specify
a fragment program to be applied to <i>entity</i> and its children.
The <i>file</i> argument gives a text file in ARB fragment program
syntax.</p>

<dt><tt>set_entity_vert_prog</tt>(<i>entity, file</i>)<dd><p> Specify
a vertex program to be applied to <i>entity</i> and its children.
The <i>file</i> argument gives a text file in ARB vertex program
syntax.</p>

<p class="note"> ARB fragment and vertex program syntaxes were chosen
because the standards are mature.  High-quality implementations are
wide-spread and available on a nice array of hardware.  If you prefer
a higher-level language, use one that can be compiled down to ARB_fp
and ARB_vp, such as Cg. </p>

</dl>

<!---------------------------------------------------------------------------->

<h4> Query </h4>
<dl>

<dt><i>x, y, z</i> = <tt>get_entity_position</tt>(<i>entity</i>)<dd><p>
Return the position (<i>x, y, z</i>) of the entity in local coordinates.
</p>

<dt><i>x, y, z</i> = <tt>get_entity_rotation</tt>(<i>entity</i>)<dd><p>
Return the rotation of the entity about the local X, Y, and Z axes.
</p>

<dt><i>x, y, z</i> = <tt>get_entity_scale</tt>(<i>entity</i>)<dd><p>
Return the scaling of the entity along the local X, Y, and Z axes.
</p>

<dt><i>a</i> = <tt>get_entity_alpha</tt>(<i>entity</i>)<dd><p> Return
the transparency value of the entity.
</p>

</dl>

<!---------------------------------------------------------------------------->

<h4> Flags </h4>
<dl>

<dt><tt>set_entity_flag</tt>(<i>entity, flag, value</i>) <dd><p> Set
or clear a flag on the given entity.  Entity flags enable and disable
extra features in the entity hierarchy.  These flags act not only on
the entity that carries them, but also on the children of that entity.
The <i>flag</i> parameter gives the set of flags to be modified, and
may be the sum of multiple flags.  The <i>value</i> parameter is a
boolean giving the desired state.  A value of <tt>true</tt> will set
the given flags, and <tt>false</tt> will clear them. </p>

<ul>

<li>

<li><tt> entity_flag_wireframe </tt><p> The wireframe flag causes
an entity and its descendants to be rendered in wireframe.  An entire
scene may be rendered in wireframe by setting the wireframe flag on a
camera or light. The application is free to set or clear a wireframe
flag value at one point in the hierarchy and set an opposite value at
a lower point.  Entities will appear as expected. </p>

<li><tt> entity_flag_hidden </tt><p> The hidden flag causes an
entity and its descendants to be omitted from rendering.  Unlike the
wireframe flag, the hidden flag <i>cannot</i> be reversed lower in the
hierarchy, as it actually causes traversal of the hierarchy to be
pruned. </p>

<li><tt> entity_flag_billboard </tt><p> Entities with the
billboard flag are drawn facing the camera, regardless of their actual
orientation.  In effect, all rotations and translations are applied as
usual, so the entity will be positioned in space as expected, but an
extra rotation is applied in order to re-aim the entity's Z axis
toward the camera. </p>

<p class="note"> Due to the manner in which the billboard
transformation is implemented, scaling operations will <i>not</i>
transform billboard entities below them in the hierarchy.  This is a
minor limitation in practice, as scaling is normally applied near the
leaves of the scene hierarchy anyway.  The common case of an entity
with local scaling <i>and</i> a local billboard flag will work
properly, but when in doubt, scale below billboarding. </p>

<li><tt> entity_flag_unlit </tt><p> Entities with the unlit flag are
drawn with all lighting disabled.  They will appear fully bright.
This is especially useful for sprite and wireframe objects which do
not have lightable surfaces.  The unlit flag affects all sub entities
and cannot be reversed lower in the hierarchy.</p>

</ul>
</dl>

<!---------------------------------------------------------------------------->

<a name="sprite"><h3> Sprite </h3>
<dl>

<dt><tt>set_sprite_bounds</tt>(<i>sprite, s0, s1, t0, t1</i>)<dd><p>
Set the texture coordinate rectangle used by a sprite.  By default,
sprites use the entire texture.  This corresponds to texture
coordinate rectangle (<i>0.0, 1.0, 0.0, 1.0</i>).  However it is
frequently useful to display only a subset of a texture on a sprite.
For example, a numerical display might use a single texture that
contains images of all of the digits 0-9, and select the digit
currently displayed simply by modifying the sprite bounds.  </p>

<dt><i>r, g, b, a</i> = <tt>get_sprite_pixel</tt>(<i>sprite, x, y</i>)
<dd><p> Return the color value of the (<i>x, y</i>) pixel of a sprite.
This function always returns 4 color components.  If the source image
does not include all four channels, then values are extrapolated:
greyscale values are copied to all three color channels and opaque
textures are assigned an alpha value of 1.</p>

<dt><i>w, h</i> = <tt>get_sprite_size</tt>(<i>sprite</i>)<dd><p>
Return the size of the sprite in pixels.</p>

</dl>

<!---------------------------------------------------------------------------->

<a name="light"><h3> Light </h3>
<dl>

<dt><tt>set_light_color</tt>(<i>light, r, g, b</i>)<dd><p> Set the
diffuse color of a light source.  </p>

</dl>

<!---------------------------------------------------------------------------->

<a name="galaxy"><h3> Galaxy </h3>
<dl>

<dt><tt>set_galaxy_magnitude</tt>(<i>galaxy</i>)<dd><p> Set the
magnitude multiplier of a galaxy.  By default, stars are rendered
using their computed luminosity.  For all but a few stars, this is far
too dim to be visible.  The magnitude multiplier can be treated as a
linear scale of apparent star size.  For example, a magnitude value of
100 will result in the very largest of stars being rendered
approximately 100 pixels across.  </p>

<p> Note that this is completely distinct from camera zoom.
Tightening the view of a camera will not result in apparently brighter
stars.  Commonly, any linear change applied to camera zoom should also
be applied to galaxy magnitude in order to provide the illusion of
increased magnification. </p>

<dt><i>index</i> = <tt>get_star_index</tt>(<i>galaxy,
camera</i>)<dd><p> Return the index of the star closest to the center
of the given <i>camera</i>.  This is useful for star selection and
galaxy navigation. </p>

<dt><i>x, y, z</i> = <tt>get_star_position</tt>(<i>galaxy,
index</i>)<dd><p> Return the position of the star at <i>index</i> of
<i>galaxy</i>.

</dl>

<!---------------------------------------------------------------------------->

<h2> Sound API </h2>

<p> Electro provides a basic audio API suitable for adding simple
sounds to an application.  It supports streaming of arbitrary stereo
or mono Ogg Vorbis audio sources.  Any number of audio streams may
play simultaneously. </p>

<dl>

<dt><i>stream</i> = <tt>load_sound</tt>(<i>filename</i>)<dd><p> Open a
reference to the named Ogg Vorbis audio stream.  This is the normal
means by which audio is imported into an Electro application.  This
function initializes a sound for playback, but does not start
playback.</p>

<dt><tt>free_sound</tt>(<i>stream</i>)<dd><p> Close an audio stream
and release all resources associated with it.
</p>

<dt><tt>play_sound</tt>(<i>stream</i>)<dd><p> Start playback of an
audio stream.  If <i>stream</i> is already playing when this function
is called, then the original playback will stop and the stream will be
rewound to the beginning before being restarted.  If it is necessary
to mix multiple instances of one specific sound, then multiple sound
objects must be used.  </p>

<dt><tt>loop_sound</tt>(<i>stream</i>)<dd><p> Begin playing an audio
stream, but automatically rewind it when the end is reached.  </p>

<dt><tt>stop_sound</tt>(<i>stream</i>)<dd><p> Stop a playing audio
stream.  This function merely stops playback, and does not release any
resources.  The stream may be restarted from the beginning.
</p>

</dl>

<!---------------------------------------------------------------------------->

<h2> Console API </h2>

<p> Electro uses a text console overlay to display error messages and enable
run-time interaction with Lua state.  This console can be enabled and disabled
by pressing F1. It also appears automatically whenever anything is printed to
it.  Applications are free to use this console for their own purposes as well.
For example, debugging information may be sent there. </p>

<dl>

<dt><tt>print_console</tt>(<i>string</i>)<dd></p> Print <i>string</i> to the
console.  To print formatted output or non-string objects, use string
concatenation or Lua <tt>string.format</tt> function. </p>

<dt><tt>clear_console</tt>()<dd><p> Clear the console to blank. </p>

<dt><tt>color_console</tt>(<i>r, g, b</i>)<dd><p> Set the console text color to
(<i>r, g, b</i>). </p>

</dl>

<!---------------------------------------------------------------------------->

<h2> Configuration API </h2>
<dl>

<dt><tt>add_host</tt>(<i>name, x, y, w, h</i>)<dd><p> Add a host.
This function is used by configuration scripts to define the structure
of the cluster driving a tiled display.  The specified parameters are
only accessed prior to the execution of the <tt>on_start</tt>
callback, so any use of it must be at the global scope. </p>

<p> The <i>name</i> argument gives the Internet hostname of the
rendering node to be used.  The <i>x, y, w, h</i> arguments give the
position and size of the area of that host's desktop to be used for
OpenGL rendering.  A given render node can only support one Electro
host.  If the same <i>name</i> argument is reused for multiple hosts,
only the first configuration will be used.  If a render node is to
handle multiple displays, they must be defined as Electro tiles...</p>

<dt><tt>add_tile</tt>(<i>name, wx, wy, ww, wh, px, py, pw, ph, origin,
right, up</i>)<dd><p> Add a tile to a host.  Like <tt>add_host</tt>,
this function is used for configuration prior to the execution of
<tt>on_start</tt>. </p>

<p> The <i>name</i> argument gives the name of the host rendering the
defined tile.  The <i>wx, wy, wh, ww</i> arguments give the position,
width, and height of the area of the host's render area to be used for
this tile.  The <i>px, py, pw, ph</i> arguments give the pixel
position and width in the global array of pixels displayed by the tile
display.  The <i>origin, right, up</i> arguments give the vectors
defining the position of the actual screen in real-space
coordinates. </p>

<p> In general, <i>wx, wy, ww, wh</i> define a framebuffer.  <i>px,
py, pw, ph</i> define the parameters of the orthogonal camera.
<i>origin, right, up</i> define the parameters of the perspective
camera.  In many cases the <i>w</i>-arguments and <i>p</i>-arguments
will be the same, but a display configuration is free to draw a
distinction between real pixel and virtual pixels.  Likewise, the tile
position vectors will be largely similar to the pixel definitions,
though a display configuration is free to define a non-planar
display.</p>

<p class="note"> There are currently some limitations on the
<i>origin, right</i> and <i>up</i> vectors.  The <i>right</i> vector
must lie in the XZ plane.  The <i>up</i> vector must lie in the YZ
plane.  The <i>origin</i> must have <i>z < 0</i>.  This rules out
CAVEs for the moment, but not a lot else.  Someday the intrepid author
will work out the math to remove this limitation in a non-hacky
fashion. </p>

<dt><i>x, y, w, h</i> = <tt>get_viewport</tt>()<dd><p> Return the
total size of the display.  The return values <i>x, y, w, h</i> give
the X position, Y position, width, and height of the rectangular union
of all tiles, in pixels.  This information is often useful when
positioning entities before an orthogonal camera, or configuring a
scene to match the aspect ratio of a display. </p>

</dl>

<!---------------------------------------------------------------------------->

<h2> Miscellaneous API </h2>
<dl>

<dt><tt>set_background</tt>(<i>r0, g0, b0</i>, [<i>r1, g1,
b1</i>])<dd><p> Set the backgound color of the display.  If only one
color (<i>r0, g0, b0</i>) is specified, the background will appear a
solid color.  If an optional second color (<i>r1, g1, b1</i>) is
supplied, the background will be drawn with a top-to-bottom gradient.
The default background has the gradient (<i>0.0, 0.0, 0.0</i>) to (<i>
0.1, 0.2, 0.4</i>). </p>

<dt><tt>enable_timer</tt>(<i>enabled</i>)<dd><p> Enable or disable the
<tt>do_timer</tt> callback.  If <i>enabled</i> has value <tt>true</tt>
then callback will occur.  </p>

<dt><i>state</i> = <tt>get_modifier</tt>(<i>modifier</i>)<dd><p>
Return the current state of a keyboard modifier.  The return value is
<tt>true</tt> if the modifier key is down.  The queryable modifiers
are:

<ul>
<li><tt>key_modifier_shift</tt>
<li><tt>key_modifier_control</tt>
<li><tt>key_modifier_alt</tt>
</ul>
</p>

<dt><i>x, y</i> = <tt>get_joystick</tt>(<i>number</i>)<dd><p>
Return the current value of the X and Y axes of joystick <i>number</i>.</p>

<p class="note"> There is no direct mechanism provided to determine
the number of joysticks connected to the system.  The capability
exists in SDL, but it isn't really necessary in Electro.  If an
application needs to count joysticks, it should observe the device
numbers recieved by the <tt>do_joystick</tt> callback.  For example,
allow the user to select the number of active joysticks by pressing
Start on each.</p>

</dl>

<!---------------------------------------------------------------------------->

<h1> Callbacks </h1>

<p> Callback functions are the mechanism by which Electro Lua
applications respond to user interface events.  An application may
define these functions as needed.  If a function exists then it is
invoked when the corresponding event occurs.  Callback functions
should return a boolean value to indicate whether the event resulted
in a dirty screen.  Returning <tt>true</tt> schedules a screen update
to occur at the next opportunity. </p>

<dl>

<dt><tt> do_start() </tt> <dd><p> This callback is invoked precisely
once at the beginning of a run.  It occurs after all of the scripts
named on the command line have finished executing, but before any
event processing begins.  Applications are free to perform Lua state
initialization upon initial execution, but Electro object
initialization <i>must</i> be performed in the <tt>do_start</tt>
function.</p>

<p class="note"> This callback is a bit of a hack.  It is necessary
because Electro objects cannot be initialized until the OpenGL context
exists.  However, the OpenGL context cannot be created until the
viewport configuration is known.  So, startup must proceed in two
distinct phases, one before context creation, and one after.  The
<tt>do_start</tt> callback is this second phase. </p>

<dt><tt> do_point(dx, dy) </tt> <dd><p> This callback is invoked
whenever the mouse pointer moves within the Electro main window.
Motion is reported relatively, so the pointer may move an unlimited
distance in any direction.  Absolute position is not reported.  If
absolute mouse position is necessary, then it must be tracked
manually, as follows: </p>

<pre>
mouse_x = 0
mouse_y = 0

function do_point(dx, dy)
    mouse_x = mouse_x + dx
    mouse_y = mouse_y + dy
    return true
end
</pre>

<dt><tt> do_click(b, s) </tt><dd><p> This callback is invoked whenever
a mouse button is pressed or released.  The <tt>b</tt> argument gives
the button number, 1, 2, 3, etc.  The <tt>s</tt> argument is a boolean
giving button state.  A value of <tt>true</tt> indicates the button
has been pressed, and <tt>false</tt> indicates it has been released.
Note, on most modern systems mouse wheel up and down are reported as
presses of buttons 4 and 5.  Button press events on wheel buttons do
not have accompanying release events. </p>

<dt><tt> do_timer(dt) </tt><dd><p> The <tt>do_timer</tt> callback is
invoked regularly while idling is enabled.  The <tt>dt</tt> argument
gives the amount of time, in seconds, that has passed since the last
time the callback was invoked.  The rate of callback is not defined,
but it will happen as often as is possible.  The <tt>do_timer</tt>
function is intended to be used to update animations and other
background processes.  Applications should be sure to return
<tt>true</tt> in order to force an update to the display.</p>

<p> If an absolute measure of time is necessary, applications should
accumulate  the <tt>dt</tt> parameter, just as they would accumulate
relative mouse motion. </p>

<pre>
time = 0

E.enable_idle(true)

function do_timer(dt)
    time = time + dt
    return true
end
</pre>

<p class="note"> The update rate of the <tt>do_timer</tt> callback is
deliberately obscured because it is nearly impossible to guarantee.
While it might make sense to allow an application to request a
callback rate, this request can only be precisely filled in a limited
number of cases.  Just trust the <tt>dt</tt>.</p>

<dt><tt> do_frame() </tt><dd><p> This callback is invoked immediately
before a frame is rendered.  This is useful for operations that should
be performed exactly once per frame. </p>

<p> In general, events are queued and several events are handled
during each frame period.  This is necessary because rendering is
usually more expensive than event handling, and re-rendering after
each event leads to sluggish performance.  Often, the most efficient
event-handling organization is to accumulate events as they arrive (as
in the <tt>do_timer</tt> and <tt>do_point</tt> examples) and use the
resulting totals to update the scene at the last moment. </p>

<p> Unlike other callbacks, the "dirty" flag return value from
<tt>do_frame</tt> is ignored, as a redraw has already been
scheduled. </p>

<dt><tt> do_keyboard(k, s) </tt><dd><p> This callback is invoked
whenever a key is pressed or released.  The <tt>s</tt> argument is a
boolean giving the key state.  The <tt>k</tt> argument gives a key
identifier.  For most keys, this gives the ASCII value of the
unshifted character.  For non-ASCII keys and modifiers it is a unique
identifier outside of the range of ASCII.  A full listing of keys and
their associated values would be lengthy and uninteresting.  When in
doubt about the value of a key, query it interactively as follows:
</p>

<pre>
function do_keyboard(k, s)
    if s then
        print(k, "down")
    else
        print(k, "up")
    end
    return false
end
</pre>

<dt><tt> do_joystick(n, b, s) </tt><dd><p> This callback is invoked
whenever a joystick button is pressed or released.  The <tt>n</tt>
argument gives the joystick device number.  The <tt>b</tt> argument
gives the button number.  The <tt>s</tt> argument is a boolean giving
button state.  Applications respond to button presses in an
event-driven fashion, but they should read joystick axis input more
continuously.  Usually joystick axes are aquired by calling
<tt>joystick_axis</tt> in a <tt>do_timer</tt> callback. </p>

</dl>

<!---------------------------------------------------------------------------->

<h1> Example </h1>

<p> What follows is a complete example of a small Electro application.
It implements the Fifteen Puzzle, the ubiquitous sliding-tile game
where an image is cut into 16 squares, one tile is removed, and the
remaining tiles are scrambled.  The object is to slide the tiles back
into place to restore the image. </p>

<p> Each important chunk of code is described in turn, and the
complete, commented source code is presented below for copying and
pasting if necessary. </p>

<pre>
image_file = "venus.png"

camera  = nil
numbers = { }
sprites = { }

curr_i = 4
curr_j = 4
time   = 0
</pre>

<p> These are the global variables.  The image filename at the top
allows the image to be changed easily.  The <tt>camera</tt> and
<tt>sprites</tt> variables give the Electro objects that make up the
scene graph.  The graph consists of a single orthogonal camera with 16
sprite objects as children.  This hierarchy is constructed in the
<tt>do_start</tt> function below. </p>

<p> The <tt>numbers</tt> variable will be initialized to a 4x4 table
of tables that indicates which tile appears at each row and column.
Each element <tt>numbers[i][j]</tt> will give an index into the
<tt>sprites</tt> table.  By moving indices around in the
<tt>numbers</tt> table, we move tiles around in the puzzle. </p>

<p> The <tt>curr_i</tt> and <tt>curr_j</tt> globals track the current
location of the blank spot.  The <tt>time</tt> variable allows the
total amount of time passed to be tracked by the <tt>do_timer</tt>
function. </p>

<pre>
function solved()
    local k = 1

    for i = 1, 4 do
        for j = 1, 4 do
            if numbers[i][j] == k then
                k = k + 1
            else
                return false
            end
        end
    end
    return true
end
</pre>

<p> The <tt>solved</tt> function lets us know when the puzzle is
complete.  When solved, the tile numbers will read in order from left
to right and top to bottom.  This function scans the rows and columns
of the <tt>numbers</tt> table checking for that property and returning
a boolean indicating the result. </p>

<pre>
function move_sprite(sprite, i, j)
    E.set_entity_position(sprite, view_x + view_w * (j - 1) / 4 + view_w / 8,
                                  view_y + view_h * (4 - i) / 4 + view_h / 8, 0)
end
</pre>

<p> This is an important bit of Electro code.  Given a puzzle row
<tt>i</tt> and column <tt>j</tt>, the <tt>move_sprite</tt> function
positions the tile object <tt>sprite</tt> at the correct location on
screen.  This function will be called any time a tile moves.  To do
its job, it must determine the bounds of the display and do some
trivial but annoying math to map puzzle row and column onto
world-space x and y.</p>

<pre>
function move_piece(di, dj)
    local next_i = curr_i + di
    local next_j = curr_j + dj

    if 1 &lt;= next_i and next_i &lt;= 4 and
       1 &lt;= next_j and next_j &lt;= 4 then

        temp                    = numbers[curr_i][curr_j]
        numbers[curr_i][curr_j] = numbers[next_i][next_j]
        numbers[next_i][next_j] = temp

        move_sprite(sprites[numbers[curr_i][curr_j]], curr_i, curr_j)
        move_sprite(sprites[numbers[next_i][next_j]], next_i, next_j)

        curr_i = next_i
        curr_j = next_j

        E.set_entity_flag(sprites[16], E.entity_flag_hidden, not solved())

        return true
    else
        return false
    end
end
</pre>

<p> The <tt>move_piece</tt> function is the meat of the fifteen
puzzle.  The arguments <tt>di</tt> and <tt>dj</tt> indicate the row
and column change of the blank space respectively.  The function
begins by confirming that the move is valid--that the blank space
would not be moving off the grid.  If valid, the contents of the blank
(in reality, the hidden 16th piece of the puzzle) are swapped with the
contents of the destination space.  The two sprites in question are
repositioned, and the puzzle is checked for completeness.  The
<tt>hidden</tt> flag of the 16th piece is set to the opposite of the
solved stutus, thus the 16th piece is displayed when the puzzle is
solved, but not otherwise. </p>

<p> The return value indicates whether the requested move is valid.
This is used when generating random moves... </p>

<pre>
function move_random()
    while true do
        local d = math.random(-1, 1)

        if math.random(0, 1) == 0 then
            if move_piece(d, 0) then
                return
            end
        else
            if move_piece(0, d) then
                return
            end
        end
    end
end
</pre>

<p> Random moves are useful for scrambling the puzzle during
initialization, and for running the app in a non-interactive
screensaver mode.  If we just pick a tile motion at random, there is
no guarantee that it will be valid, so we loop until
<tt>move_piece</tt> returns <tt>true</tt> to indicate success. </p>

<pre>
function do_timer(dt)
    time = time + dt

    if time &gt; 0.25 then
        move_random()
        time = 0
        return true
    end

    return false
end
</pre>

<p> The <tt>do_timer</tt> callback is where non-interactive random
motions are generated.  It tracks the amount of time that has passed,
and triggers a move after a quarter of a second.  It returns
<tt>true</tt> to indicate that a move has occurred and the screen
needs to be redrawn. </p>

<pre>
function do_keyboard(k, s)
    if s then
        if k == 276 then move_piece( 0,  1) end
        if k == 275 then move_piece( 0, -1) end
        if k == 273 then move_piece( 1,  0) end
        if k == 274 then move_piece(-1,  0) end

        if k == 282 then E.enable_timer(true)  end
        if k == 283 then E.enable_timer(false) end
    end
    return true
end
</pre>

<p> The <tt>do_keyboard</tt> callback is where interactive motions are
generated.  Arrow-key presses trigger moves.  The F1 and F2 keys
enable and disable the <tt>do_timer</tt> callback, in effect putting
the puzzle into non-interactive mode.  For simplicity, all keypresses
trigger a screen update.  This is unnecessary, but brief.</p>

<pre>
function do_start()

    view_x, view_y, view_w, view_h = E.get_viewport()

    camera = E.create_camera(E.camera_type_orthogonal)
    E.set_entity_flag(camera, E.entity_flag_unlit, true);

    numbers[1] = {  1,  2,  3,  4 }
    numbers[2] = {  5,  6,  7,  8 }
    numbers[3] = {  9, 10, 11, 12 }
    numbers[4] = { 13, 14, 15, 16 }

    for i = 1, 16 do
        sprites[i] = E.create_sprite(image_file)

        local sw, sh = E.get_sprite_size(sprites[i])

        E.parent_entity(sprites[i], camera)
        E.set_entity_scale(sprites[i], 0.25 * view_w / sw,
                                       0.25 * view_h / sh, 1.0)
    end

    for i = 1, 4 do
        for j = 1, 4 do
            local x0 = (j - 1) / 4
            local x1 = (j - 0) / 4
            local y0 = (4 - i) / 4
            local y1 = (5 - i) / 4

            move_sprite(sprites[numbers[i][j]], i, j)
            E.set_sprite_bounds(sprites[numbers[i][j]], x0, x1, y0, y1)
        end
    end

    return true
end
</pre>

<p> Finally, here is the <tt>do_start</tt> callback.  This function is
called immediately after Electro starts.  It is responsible for doing
any and all initialization necessary to get the application off the
ground. </p>

<p> For the fifteen puzzle, we begin by creating an orthogonal camera,
which will be the root of our hierarchy.  We want all of our puzzle
pieces to be rendered at full brightness, so we disable lighting on
the entire scene by setting the <tt>unlit</tt> flag at this root.  We
then create 16 child sprite objects to represent the puzzle tiles.
Together, these 16 sprites should fill the display, so we must
determine both the size of the display and the size of the sprite in
order to scale each sprite to 1/16th of the area of the display.</p>

<p> Then, we create the <tt>numbers</tt> table.  It is simply a 4x4
table of tables initialized to a solved configuration.  We use the row
and column numbers of this table to position our 16 sprites on screen.
We also use each sprite's initial row and column number to specify the
sprite bounds, that is, we determine what subset of the image should
be mapped onto each sprite. </p>

<p> That is all there is to it. </p>

<!---------------------------------------------------------------------------->

<h2> The full source of the Fifteen Puzzle example </h2>

<pre>
image_file = "venus.jpg"

view_x = 0
view_y = 0
view_w = 0
view_h = 0

camera  = nil
numbers = { }
sprites = { }

curr_i  = 4
curr_j  = 4
time    = 0

function move_sprite(sprite, i, j)
    E.set_entity_position(sprite, view_x + view_w * (j - 1) / 4 + view_w / 8,
                                  view_y + view_h * (4 - i) / 4 + view_h / 8, 0)
end

function solved()
    local k = 1

    for i = 1, 4 do
        for j = 1, 4 do
            if numbers[i][j] == k then
                k = k + 1
            else
                return false
            end
        end
    end
    return true
end

function move_piece(di, dj)
    local next_i = curr_i + di
    local next_j = curr_j + dj

    -- Confirm that the move is valid.

    if 1 <= next_i and next_i <= 4 and
       1 <= next_j and next_j <= 4 then

        -- Swap the moving piece with the blank piece.

        temp                    = numbers[curr_i][curr_j]
        numbers[curr_i][curr_j] = numbers[next_i][next_j]
        numbers[next_i][next_j] = temp

        -- Set the new on-screen locations of the moving sprites.

        move_sprite(sprites[numbers[curr_i][curr_j]], curr_i, curr_j)
        move_sprite(sprites[numbers[next_i][next_j]], next_i, next_j)

        curr_i = next_i
        curr_j = next_j

        -- Set the visibility of the 16th piece to indicate solution.

        E.set_entity_flag(sprites[16], E.entity_flag_hidden, not solved())

        return true
    else
        return false
    end
end

function move_random()
    while true do
        local d = math.random(-1, 1)

        if math.random(0, 1) == 0 then
            if move_piece(d, 0) then
                return
            end
        else
            if move_piece(0, d) then
                return
            end
        end
    end
end

function do_start()

    view_x, view_y, view_w, view_h = E.get_viewport()

    camera = E.create_camera(E.camera_type_orthogonal)
    E.set_entity_flag(camera, E.entity_flag_unlit, true);

    -- Initialize an array that maps rows and columns onto puzzle pieces.

    numbers[1] = {  1,  2,  3,  4 }
    numbers[2] = {  5,  6,  7,  8 }
    numbers[3] = {  9, 10, 11, 12 }
    numbers[4] = { 13, 14, 15, 16 }

    -- Add 16 sprites and scale each to 1/16th the size of the display.

    for i = 1, 16 do
        sprites[i] = E.create_sprite(image_file)

        local sw, sh = E.get_sprite_size(sprites[i])

        E.parent_entity(sprites[i], camera)
        E.set_entity_scale(sprites[i], 0.25 * view_w / sw,
                                       0.25 * view_h / sh, 1.0)
    end

    -- Assign 1/16th of the image to each sprite.

    for i = 1, 4 do
        for j = 1, 4 do
            local x0 = (j - 1) / 4
            local x1 = (j - 0) / 4
            local y0 = (4 - i) / 4
            local y1 = (5 - i) / 4

            move_sprite(sprites[numbers[i][j]], i, j)
            E.set_sprite_bounds(sprites[numbers[i][j]], x0, x1, y0, y1)
        end
    end

    return true
end

function do_keyboard(k, s)
    if s then
        -- If an arrow key has been pressed, move a puzzle piece.

        if k == 276 then move_piece( 0,  1) end
        if k == 275 then move_piece( 0, -1) end
        if k == 273 then move_piece( 1,  0) end
        if k == 274 then move_piece(-1,  0) end

        -- If autoplay has been switched, toggle the idle function.

        if k == 283 then E.enable_timer(true)  end
        if k == 284 then E.enable_timer(false) end
    end
    return true
end

function do_timer(dt)
    time = time + dt

    if time > 0.25 then
        move_random()
        time = 0
      return true
    end

    return false
end
</pre>

<!---------------------------------------------------------------------------->

<p class="note" style="text-align: right"><i> rlk (at) evl.uic.edu </i></p>
