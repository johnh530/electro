<html>
<head>
  <style type="text/css">
    body   { text-align:   justify;
             margin-right: 10%;
             margin-left:  10%; }
    h1     { margin-left:  -9%; }
    h2     { margin-left:  -6%; }
    h3     { margin-left:  -3%; }
    pre    { background: #FFFFCC; padding: 1em; }
    p.note { background: #CCFFFF; padding: 1em; }
  </style>
</head>
<body>

<!---------------------------------------------------------------------------->

<pre style="font-size:3em; font-weight:bold; padding: 0.25em">
  |||
  O o  Electro
   -
</pre>

<p> Electro is an application development framework designed for use on
cluster-driven tiled displays.  Electro is based upon the MPI process model
and is bound to the Lua programming language.  With support for 3D graphics,
2D graphics, audio, and input handling, Electro provides an easy-to-use
scripting system for interactive applications spanning multiple processors and
displays. </p>

<h1> This Document </h1>

<p> This document details the functions and data types of the Electro API.  A
knowledge of the Lua Programming Language, version 5.0, is prerequisite.  Lua
documentation and tutorials may be found at <a
href="http://www.lua.org/docs.html"> the official Lua site. </a></p>

<p> This document includes a number of Lua code examples.  These examples are
distinguished from the main text as follows: </p>

<pre>
print("Hello, World!")
</pre>

<p> This document also includes a number of paragraphs giving design
rationale.  These describe some of the trade-offs and design decisions made
during the development of Electro.  They are presented here in the hope that
they will provide the reader with a more thorough understanding of the details
of the implementation.  Rationale paragraphs are distinguished from the main
text as follows: </p>

<p class="note"> Electro adheres to a number of closely-held design
principles.  The primary principles are simplicity, orthogonality, and
efficiency.  Violations of these principles do appear, but not without serious
consideration. </p>

<!---------------------------------------------------------------------------->

<h1> Types </h1>

<!---------------------------------------------------------------------------->

<h2> Entity </h2>

<!---------------------------------------------------------------------------->

<h2> Object </h2>

<!---------------------------------------------------------------------------->

<h2> Sprite </h2>

<!---------------------------------------------------------------------------->

<h2> Camera </h2>

<!---------------------------------------------------------------------------->

<h2> Light </h2>

<!---------------------------------------------------------------------------->

<h2> Pivot </h2>

<!---------------------------------------------------------------------------->

<h1> Functions </h1>

<!---------------------------------------------------------------------------->

<h2> Entity Functions </h2>

<p> The following functions act on entities.  The entity argument of each
function may take any entity value, including object, sprite, lightsource, and
camera. </p>

<h3> Absolute Transformation </h3>

<dl>

<dt><tt> set_entity_position(entity, x, y, z) </tt><dd><p> Specify
the position of the entity.  Position is given in the coordinate
system of the entity's parent. </p>

<dt><tt> set_entity_rotation(entity, x, y, z) </tt><dd><p> Specify
the rotation of the entity.  The 3 values give the angles of rotation
in degrees about the X, Y, and Z axes.  Rotation is given in the
coordinate system of the entity's parent. </p>

<dt><tt> set_entity_scale(entity, x, y, z) </tt><dd><p> Specify the
scale of the entity.  The 3 values give scale multipliers along the
X, Y, and Z axes.  Scale is given in the coordinate system of the
entity's parent. </p>

</dl>

<h3> Relative Transformation </h3>

<p class="note"> Strictly speaking, to provide both absolute and relative
transformation functions is to violate the principle of orthogonality.  In
this case, I just couldn't resist.  Inspiration for this feature is drawn from
Blitz3D, which showed that relative transform is very beginner-friendly,
leading to a very intuitive turtle-style system of entity control. </p>

<dl>

<dt><tt> move_entity(entity, x, y, z) </tt><dd><p> Move the entity relative to
its current position.  X is to the right, Y is up, and Z axis is to the rear,
as defined by the entity's current orientation. </p>

<p class="note"> It might be more clear to the beginner if the Z axis to
pointed forward rather than back.  However, this would be in conflict with the
normal right-handed coordinate system, and would only lead to inconsistency
and confusion for the experienced 3D user. </p>

<dt><tt> turn_entity(entity, x, y, z) </tt><dd><p> Rotate the entity relative
to its current orientation.  Rotation about the X, Y, and Z axes corresponds
to pitch, yaw, and roll, respectively. </p>

</dl>

<h3> Flags </h3>

<dl>

<dt><tt> set_entity_flag(entity, flag, value) </tt><dd><p> Set or
clear a flag on the given entity.  Entity flags enable and disable
extra features in the entity hierarchy.  These flags act not only
on the entity that carries them, but also on the children of that
entity.  The <tt>flag</tt> parameter gives the set of flags to be
modified, and may be the sum of multiple flags.  The <tt>value</tt>
parameter is a boolean giving the desired state.  A value of
<tt>true</tt> will set the given flags, and <tt>false</tt> will
clear them. <p>

<dl>

<dt><tt> entity_flag_wireframe </tt><dd><p> The wireframe flag causes an
entity and its descendants to be rendered in wireframe.  An entire scene may
be rendered in wireframe by setting the wireframe flag on a camera or
light. The application is free to set or clear a wireframe flag value at one
point in the hierarchy and set an opposite value at a lower point.  Entities
will appear as expected. </p>

<dt><tt> entity_flag_hidden </tt><dd><p> The hidden flag causes an entity and
its descendants to be omitted from rendering.  Unlike the wireframe flag, the
hidden flag <i>cannot</i> be reversed lower in the hierarchy, as it actually
causes traversal of the hierarchy to be pruned.</p>

<dt><tt> entity_flag_billboard </tt><dd><p> Entities with the billboard flag
are drawn facing the camera, regardless of their actual orientation.  In
effect, all rotations and translations are applied as usual, so the entity
will be positioned in space as expected, but an extra rotation is applied in
order to re-aim the entity's Z axis toward the camera.  </p>

<p class="note"> Due to the manner in which the billboard transformation is
implemented, scaling operations will <i>not</i> transform billboard entities
below them in the hierarchy.  This is a minor limitation in practice, as
scaling is normally applied near the leaves of the scene hierarchy anyway.
The common case of an entity with local scaling <i>and</i> a local billboard
flag will work properly, but when in doubt, scale below billboarding. </p>

</dl>
</dl>

<!---------------------------------------------------------------------------->

<h2> Configuration Functions </h2>

<dl>

<dt><tt> add_tile(local_x, local_y, global_x, global_y, width, height) </tt>

<dd><p> Make a tile. </p>

</dl>

<!---------------------------------------------------------------------------->

<h1> Callbacks </h1>

<p> Callback functions are the mechanism by which Electro Lua applications
respond to user interface events.  An application may define these functions
as needed.  If a function exists then it is invoked when the corresponding
event occurs.  Callback functions should return a boolean value to indicate
whether the event resulted in a dirty screen.  Returning <tt>true</tt>
schedules a screen update to occur at the next opportunity. </p>

<dl>

<dt><tt> do_start() </tt> <dd><p> This callback is invoked precisely once at
the beginning of a run.  It occurs after all of the scripts named on the
command line have finished executing, but before any event processing begins.
Applications are free to perform Lua state initialization upon initial
execution, but Electro object initialization <i>must</i> be performed in the
<tt>do_start</tt> function.</p>

<p class="note"> This callback is a bit of a hack.  It is necessary because
Electro objects cannot be initialized until the OpenGL context exists.
However, the OpenGL context cannot be created until the viewport configuration
is known.  So, startup must proceed in two distinct phases, one before context
creation, and one after.  The <tt>do_start</tt> callback is this second
phase. </p>

<dt><tt> do_point(dx, dy) </tt> <dd><p> This callback is invoked whenever the
mouse pointer moves within the Electro main window.  Motion is reported
relatively, so the pointer may move an unlimited distance in any direction.
Absolute position is not reported.  If absolute mouse position is necessary,
then it must be tracked manually, as follows: </p>

<pre>
mouse_x = 0
mouse_y = 0

function do_point(dx, dy)
    mouse_x = mouse_x + dx
    mouse_y = mouse_y + dy
    return true
end
</pre>

<dt><tt> do_click(b, s) </tt><dd><p> This callback is invoked whenever a mouse
button is pressed or released.  The <tt>b</tt> argument gives the button
number, 1, 2, 3, etc.  The <tt>s</tt> argument is a boolean giving button
state.  A value of <tt>true</tt> indicates the button has been pressed, and
<tt>false</tt> indicates it has been released.  Note, on most modern systems
mouse wheel up and down are reported as presses of buttons 4 and 5.  Button
press events on wheel buttons do not have accompanying release events. </p>

<dt><tt> do_timer(dt) </tt><dd><p> The <tt>do_timer</tt> callback is invoked
regularly while idling is enabled.  The <tt>dt</tt> argument gives the amount
of time, in seconds, that has passed since the last time the callback was
invoked.  The rate of callback is not defined, though it may be inferred to be
"often enough."  In practice it is usually around 30 times per second, though
this will decrease with graphical complexity.  The <tt>do_timer</tt> function
is intended to be used to update animations and other background processes.
Applications should be sure to return <tt>true</tt> in order to force an
update to the display.</p>

<p> If an absolute measure of time is necessary, applications should
accumulate  the <tt>dt</tt> parameter, just as they would accumulate
relative mouse motion. </p>

<pre>
time = 0

function do_timer(dt)
    time = time + dt
    return true
end
</pre>

<p class="note"> The update rate of the <tt>do_timer</tt> callback is
deliberately obscured because it is nearly impossible to guarantee.  While it
might make sense to allow an application to request a callback rate, this
request can only be precisely filled in a limited number of cases.  The idle
timer does <i>not</i> free-run.  Free-running in Electro is bad because MPI
synchronization is unpredictable and events tend to queue up, leading to
sluggish behavior.  The application developer may count on the fact that
<tt>do_timer</tt> is invoked as often as is possible, such that performance
will not suffer. </p>

<dt><tt> do_keyboard(k, s) </tt><dd><p> This callback is invoked whenever a
key is pressed or released.  The <tt>s</tt> argument is a boolean giving the
key state.  The <tt>k</tt> argument gives a key identifier.  For most keys,
this gives the ASCII value of the unshifted character.  For non-ASCII keys and
modifiers it is a unique identifier outside of the range of ASCII.  A full
listing of keys and their associated values would be lengthy and
uninteresting.  When in doubt about the value of a key, query it interactively
as follows: </p>

<pre>
function do_keyboard(k, s)
    if s then
        print(k, "down")
    else
        print(k, "up")
    end
    return false
end
</pre>

<dt><tt> do_joystick(n, b, s) </tt><dd><p> This callback is invoked whenever a
joystick button is pressed or released.  The <tt>n</tt> argument gives the
joystick device number.  The <tt>b</tt> argument gives the button number.  The
<tt>s</tt> argument is a boolean giving button state.  Applications respond to
button presses in an event-driven fashion, but they should read joystick axis
input more continuously.  Usually joystick axes are aquired by calling
<tt>joystick_axis</tt> in a <tt>do_timer</tt> callback. </p>

</dl>

<!---------------------------------------------------------------------------->

<h1> Example </h1>

<p> What follows is a complete example of a small Electro application.
It implements the Fifteen Puzzle, the ubiquitous sliding-tile game
where an image is cut into 16 squares, one tile is removed, and the
remaining tiles are scrambled.  The object is to slide the tiles
back into place to restore the image. </p>

<p> Each important chunk of code is described in turn, and the
complete, commented source code is presented below for copying and
pasting if necessary. </p>

<pre>
image_file = "venus.png"

camera  = nil
numbers = { }
sprites = { }

curr_i = 4
curr_j = 4
time   = 0
</pre>

<p> These are the global variables.  The image filename at the top
allows the image to be changed easily.  The <tt>camera</tt> and
<tt>sprites</tt> variables give the Electro objects that make up
the scene graph.  The graph consists of a single orthogonal camera
with 16 sprite objects as children.  This hierarchy is constructed
in the <tt>do_start</tt> function below. </p>

<p> The <tt>numbers</tt> variable will be initialized to a 4x4 table
of tables that indicates which tile appears at each row and column.
Each element <tt>numbers[i][j]</tt> will give an index into the
<tt>sprites</tt> table.  By moving indices around in the <tt>numbers</tt>
table, we move tiles around in the puzzle. </p>

<p> The <tt>curr_i</tt> and <tt>curr_j</tt> globals track the current
location of the blank spot.  The <tt>time</tt> variable allows the
total amount of time passed to be tracked by the <tt>do_timer</tt>
function. </p>

<pre>
function solved()
    local k = 1

    for i = 1, 4 do
        for j = 1, 4 do
            if numbers[i][j] == k then
                k = k + 1
            else
                return false
            end
        end
    end
    return true
end
</pre>

<p> The <tt>solved</tt> function lets us know when the puzzle is
complete.  When solved, the tile numbers will read in order from
left to right and top to bottom.  This function scans the rows and
columns of the <tt>numbers</tt> table checking for that property
and returning a boolean indicating the result. </p>

<pre>
function move_sprite(sprite, i, j)
    local t, l, b, r = E.get_viewport()

    local w = r - l
    local h = t - b

    E.set_entity_position(sprite, l + w * (j - 1) / 4 + w / 8,
                                  b + h * (4 - i) / 4 + h / 8, 0)
end
</pre>

<p> This is an important bit of Electro code.  Given a puzzle row
<tt>i</tt> and column <tt>j</tt>, the <tt>move_sprite</tt> function
positions the tile object <tt>sprite</tt> at the correct location
on screen.  This function will be called any time a tile moves.  To
do its job, it must determine the bounds of the display and do some
trivial but annoying math to map puzzle row and column onto world-space
x and y.</p>

<pre>
function move_piece(di, dj)
    local next_i = curr_i + di
    local next_j = curr_j + dj

    if 1 &lt;= next_i and next_i &lt;= 4 and
       1 &lt;= next_j and next_j &lt;= 4 then

        temp                    = numbers[curr_i][curr_j]
        numbers[curr_i][curr_j] = numbers[next_i][next_j]
        numbers[next_i][next_j] = temp

        move_sprite(sprites[numbers[curr_i][curr_j]], curr_i, curr_j)
        move_sprite(sprites[numbers[next_i][next_j]], next_i, next_j)

        curr_i = next_i
        curr_j = next_j

        E.set_entity_flag(sprites[16], E.entity_flag_hidden, not solved())

        return true
    else
        return false
    end
end
</pre>

<p> The <tt>move_piece</tt> function is the meat of the fifteen
puzzle.  The arguments <tt>di</tt> and <tt>dj</tt> indicate the row
and column change of the blank space respectively.  The function
begins by confirming that the move is valid--that the blank space
would not be moving off the grid.  If valid, the contents of the
blank (in reality, the hidden 16th piece of the puzzle) are swapped
with the contents of the destination space.  The two sprites in
question are repositioned, and the puzzle is checked for completeness.
The <tt>hidden</tt> flag of the 16th piece is set to the opposite
of the solved stutus, thus the 16th piece is displayed when the
puzzle is solved, but not otherwise. </p>

<p> The return value indicates whether the requested move is valid.
This is used when generating random moves... </p>

<pre>
function move_random()
    while true do
        local d = math.random(-1, 1)

        if math.random(0, 1) == 0 then
            if move_piece(d, 0) then
                return
            end
        else
            if move_piece(0, d) then
                return
            end
        end
    end
end
</pre>

<p> Random moves are useful for scrambling the puzzle during
initialization, and for running the app in a non-interactive
screensaver mode.  If we just pick a tile motion at random, there
is no guarantee that it will be valid, so we loop until <tt>move_piece</tt>
returns <tt>true</tt> to indicate success. </p>

<pre>
function do_timer(dt)
    time = time + dt

    if time &gt; 0.25 then
        move_random()
        time = 0
        return true
    end

    return false
end
</pre>

<p> The <tt>do_timer</tt> callback is where non-interactive random
motions are generated.  It tracks the amount of time that has passed,
and triggers a move after a quarter of a second.  It returns
<tt>true</tt> to indicate that a move has occurred and the screen
needs to be redrawn. </p>

<pre>
function do_keyboard(k, s)
    if s then
        if k == 276 then move_piece( 0,  1) end
        if k == 275 then move_piece( 0, -1) end
        if k == 273 then move_piece( 1,  0) end
        if k == 274 then move_piece(-1,  0) end

        if k == 282 then E.set_idle(true)  end
        if k == 283 then E.set_idle(false) end
    end
    return true
end
</pre>

<p> The <tt>do_keyboard</tt> callback is where interactive motions
are generated.  Arrow-key presses trigger moves.  The F1 and F2
keys enable and disable the <tt>do_timer</tt> callback, in effect
putting the puzzle into non-interactive mode.  For simplicity, all
keypresses trigger a screen update.  This is unnecessary, but
brief.</p>

<pre>
function do_start()
    local t, l, b, r = E.get_viewport()

    local w = r - l
    local h = t - b

    camera = E.create_camera(E.camera_type_orthogonal)
    E.set_entity_flag(camera, E.entity_flag_unlit, true);

    for i = 1, 16 do
        sprites[i] = E.create_sprite(image_file)

        local sw, sh = E.get_sprite_size(sprites[i])

        E.parent_entity(sprites[i], camera)
        E.set_entity_scale(sprites[i], 0.25 * w / sw,
                                       0.25 * h / sh, 1.0)
    end

    numbers[1] = {  1,  2,  3,  4 }
    numbers[2] = {  5,  6,  7,  8 }
    numbers[3] = {  9, 10, 11, 12 }
    numbers[4] = { 13, 14, 15, 16 }

    for i = 1, 4 do
        for j = 1, 4 do
            local x0 = (j - 1) / 4
            local x1 = (j - 0) / 4
            local y0 = (4 - i) / 4
            local y1 = (5 - i) / 4

            move_sprite(sprites[numbers[i][j]], i, j)
            E.set_sprite_bounds(sprites[numbers[i][j]], x0, x1, y0, y1)
        end
    end

    return true
end
</pre>

<p> Finally, here is the <tt>do_start</tt> callback.  This function
is called immediately after Electro starts.  It is responsible for
doing any and all initialization necessary to get the application
off the ground. </p>

<p> For the fifteen puzzle, we begin by creating an orthogonal
camera, which will be the root of our hierarchy.  We want all of
our puzzle pieces to be rendered at full brightness, so we disable
lighting on the entire scene by setting the <tt>unlit</tt> flag at
this root.  We then create 16 child sprite objects to represent the
puzzle tiles.  Together, these 16 sprites should fill the display,
so we must determine both the size of the display and the size of
the sprite in order to scale each sprite to 1/16th of the area of
the display.</p>

<p> Then, we create the <tt>numbers</tt> table.  It is simply a 4x4
table of tables initialized to a solved configuration.  We use the
row and column numbers of this table to position our 16 sprites on
screen.  We also use each sprite's initial row and column number
to specify the sprite bounds, that is, we determine what subset of
the image should be mapped onto each sprite. </p>

<p> That is all there is to it. </p>

<!---------------------------------------------------------------------------->

<h2> The full source of the Fifteen Puzzle example </h2>
<pre>
image_file = "venus.png"

camera  = nil
numbers = { }
sprites = { }

curr_i = 4
curr_j = 4
time   = 0

function move_sprite(sprite, i, j)
    local t, l, b, r = E.get_viewport()

    local w = r - l
    local h = t - b

    E.set_entity_position(sprite, l + w * (j - 1) / 4 + w / 8,
                                  b + h * (4 - i) / 4 + h / 8, 0)
end

function solved()
    local k = 1

    for i = 1, 4 do
        for j = 1, 4 do
            if numbers[i][j] == k then
                k = k + 1
            else
                return false
            end
        end
    end
    return true
end

function move_piece(di, dj)
    local next_i = curr_i + di
    local next_j = curr_j + dj

    -- Confirm that the move is valid.

    if 1 &lt;= next_i and next_i &lt;= 4 and
       1 &lt;= next_j and next_j &lt;= 4 then

        -- Swap the moving piece with the blank piece.

        temp                    = numbers[curr_i][curr_j]
        numbers[curr_i][curr_j] = numbers[next_i][next_j]
        numbers[next_i][next_j] = temp

        -- Set the new on-screen locations of the moving sprites.

        move_sprite(sprites[numbers[curr_i][curr_j]], curr_i, curr_j)
        move_sprite(sprites[numbers[next_i][next_j]], next_i, next_j)

        curr_i = next_i
        curr_j = next_j

        -- Set the visibility of the 16th piece to indicate solution.

        E.set_entity_flag(sprites[16], E.entity_flag_hidden, not solved())

        return true
    else
        return false
    end
end

function move_random()
    while true do
        local d = math.random(-1, 1)

        if math.random(0, 1) == 0 then
            if move_piece(d, 0) then
                return
            end
        else
            if move_piece(0, d) then
                return
            end
        end
    end
end

function do_start()
    local t, l, b, r = E.get_viewport()

    local w = r - l
    local h = t - b

    camera = E.create_camera(E.camera_type_orthogonal)
    E.set_entity_flag(camera, E.entity_flag_unlit, true);

    -- Add 16 sprites and scale each to 1/16th the size of the display.

    for i = 1, 16 do
        sprites[i] = E.create_sprite(image_file)

        local sw, sh = E.get_sprite_size(sprites[i])

        E.parent_entity(sprites[i], camera)
        E.set_entity_scale(sprites[i], 0.25 * w / sw,
                                       0.25 * h / sh, 1.0)
    end

    -- Initialize an array that maps rows and columns onto puzzle pieces.

    numbers[1] = {  1,  2,  3,  4 }
    numbers[2] = {  5,  6,  7,  8 }
    numbers[3] = {  9, 10, 11, 12 }
    numbers[4] = { 13, 14, 15, 16 }

    -- Assign 1/16th of the image to each sprite.

    for i = 1, 4 do
        for j = 1, 4 do
            local x0 = (j - 1) / 4
            local x1 = (j - 0) / 4
            local y0 = (4 - i) / 4
            local y1 = (5 - i) / 4

            move_sprite(sprites[numbers[i][j]], i, j)
            E.set_sprite_bounds(sprites[numbers[i][j]], x0, x1, y0, y1)
        end
    end

    return true
end

function do_keyboard(k, s)
    if s then
        -- If an arrow key has been pressed, move a puzzle piece.

        if k == 276 then move_piece( 0,  1) end
        if k == 275 then move_piece( 0, -1) end
        if k == 273 then move_piece( 1,  0) end
        if k == 274 then move_piece(-1,  0) end

        -- If autoplay has been switched, toggle the idle function.

        if k == 282 then E.set_idle(true)  end
        if k == 283 then E.set_idle(false) end
    end
    return true
end

function do_timer(dt)
    time = time + dt

    if time &gt; 0.25 then
        move_random()
        time = 0
        return true
    end

    return false
end
</pre>

<!---------------------------------------------------------------------------->

<p class="note" style="text-align: right"><i> rlk (at) evl.uic.edu </i></p>
